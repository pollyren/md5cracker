# md5cracker 
Project Report — Polly Ren

## Background
In the modern world, a vast majority of accounts are protected by a password for security. These passwords are stored by the application and checked against upon login to verify a user's identity. However, passwords are typically not stored in plaintext, as this makes them highly vulnerable to misuse in the event the passwords are compromised. Instead, the password is passed through a cryptographic hash function, which converts it into a fixed-size string of characters; this hashed value is what gets stored. Hashing passwords introduces an additional layer of security in case of a data breach. Hash functions are designed to be one-way; once a password is hashed, it is mathematically impossible to revert the hashed value back to the original password. This property ensures that even if an attacker obtains the hashed password, they cannot easily determine the original password. Furthermore, hashing can be computationally expensive, making it infeasible for an attacker to brute-force a large number of passwords. For instance, guessing a 6-character password over a length-80 character set, can, in the worst case, require hashing $80^6$ (that's more than 262 billion) different guesses, which is very computatioinal intensive.

`md5cracker` is a brute-force password cracker that harnesses the power of GPU programming to accelerate the password cracking process for MD5-hashed passwords. Brute-force password cracking is an embarassingly-parallel problem, that is, the process of guessing a password and checking the guess can be done independently and in parallel. This program leverages the inherent parallelism of brute-force attacks to rapidly explore the vast space of possible password combinations, ultimately expediting the cracking process by orders of magnitude and outperforming CPU-based sequential methods. After the passwords are guessed, the program generates a report of the time required to crack each password.

## Usage and arguments
The program is designed to crack a specified number of hashed passwords using either a GPU-based parallel method or a CPU-based sequential algorithm. 

#### Input file generation
The program takes as input a list of passwords and their corresponding hashes from the `inputs/` directory, with filenames `N_hashed.txt` and `N_plain.txt`. These hashed and plaintexts are randomly generated using the `generate_passwords.py` script. 

To generate $N$ random passwords with length $l\sim N(3.5, 1)$, run the following from the `utils/` directory:
```
python generate_passwords.py N
```

To generate $N$ random passwords with uniform length $l$, run the following from the `utils/` directory:
```
python generate_passwords.py N -u l
```
This will produce `inputs/Nu_hashed.txt` and `inputs/Nu_plain.txt` (note the additional "u" in the filename).

#### Compiling
The `Makefile` in the `src/` directory compiles the source files. Run `make clean; make` in the `src/` directory to compile. This produces a `cracker` executable in the `src/` directory.

#### Running GPU program
To run the GPU-accelerated version of the program, use the following command from the root of the repository:
```
src/cracker [-n <num_passwords>] [-u] [-r] [-t] [-p]
```
- `-n <num_passwords>`: Specifies the number of passwords to process (default=10). This should match the number of passwords generated in the _Input file generation_ process above.
- `-u`: Crack uniform length passwords. These passwords must have been generated by uniform-length password generation above.
- `-r`: Generates a report with the time taken to crack each password and a timing summary, saved as `crack_report_gpu_<num_passwords>.txt` or `crack_report_seq_<num_passwords>.txt`.
- `-t`: Enables timing, recording the total time taken to crack all passwords in `times.csv` or `times_unif.csv`.
- `-p`: Tracks cracking progress, used for debugging.

#### Running sequential program
The arguments for the sequential program are largely similar to the GPU program with the addition of the `-s` flag:
```
src/cracker [-n <num_passwords>] -s [-u] [-r] [-t] [-p]
```

#### Results and outputs
The program produces a list of the cracked plaintext passwords in `N_recovered.txt` or `Nu_recovered.txt`.

If provided the `-r` flag, the program will also generate a more-detailed report of the time taken to crack each password and a timing summary as described above.

#### Using the `run.sh` script
The `run.sh` script combines the input file generation, compilation and execution into a single script. Because the script submits jobs to a slurm scheduler based on environment variables, please check that these variables are properly initialised in the `setup_env.sh` script and updated using `source setup_env.sh`. Then, to run the `run.sh` script, use the following command:
```
sbatch run.sh -n <num_passwords> [-u <uniform_length>] [-s] [-r] [-t] [-p]
```

## Implementation
The program uses brute-force, guessing each possible password combination until the correct one is found. In the sequential version, each possible password combinations are generated iteratively for a given password length, hashed using the MD5 algorithm (implemented in `md5.cu`, courtesy of open source) and compared against the target hash. If the hashes match, the underlying plaintext password has been found and the guess is terminated for that password. With the length-80 character set, there are $80^1$ possible length-1 passwords, $80^2$ possible length-2 passwords, etc. Therefore, the number of passwords to guess increases exponentially as the password space is searched. It is not difficult to see that this is a compute-bound algorithm and because this is conducted sequentially, there is no real use of load balancing. However, by checking shorter passwords first, this can potentially reduce the number of iterations required to crack a password. Additionally, the latency of the sequential program is rather high due to the nature of sequential brute-force search; each possible combination must be hashed and checked one after another. As such, there is also low throughput as the performance is bound by the resources of a single CPU core.

The implementation of the GPU program is very similar to the sequential program. However, by leveraging the parallel computing capabilities of the GPU to search the password space much faster. I searched the N-character password space in parallel, that is, all the same length passwords are guessed within the same kernel launch and each thread within a kernel is responsible for testing a specific range of passwords based on the thread coarsening factor of 4. The search space is distributed mostly evenly among all the threads, thus balancing the load that each thread handles. As such, the latency is much smaller compared to the sequential version. Latency is further minimised by using constant memory to store the character set and shared memory to reduce accesses to global memory. Accordingly, the GPU program also has signficantly higher throughput, as thousands of passwords can be guessed and checked simultaneously. This concurrency drastically reduces the amount of the time needed to traverse the search space and ultimately find the correct password.

The report generation option also raises a few interesting implementation decisions. The time associated with cracking each password in the input list of the passwords is stored, which allows for more detailed timing information about each password, as well as summary statistics on runtime. In the sequential version, the elapsed time for each password is measured using the CPU clock and the total time is computed by sequentially summing up the individual times associated with each password (note this total time is separate from the timing mechanism used by the `-t` flag). In the GPU version, events are used to measure time, which turned out to be far more precise than relying on the CPU clock. To sum the individual times in computing the total time, a reduction kernel is used to add the times together in parallel. This is particularly beneficial for cracking a larger number of passwords as it enables a more parallelised summation of times.

#### Challenges
The main challenge with implementation is the vastness of the password search space for each additional character in the password. Even with parallel computing and GPUs, it can take a few hours to crack a 8-character password (that's over 20 trillion combinations to search). Initially, I had planned to design the program to support up to 10-character passwords, but between splitting the work through thread coarsening and the time it took to run the program with a longer password was infeasible. In my original implmentation, the kernel for 7+-character passwords would try to launch over 2 billion blocks, each with 256 threads. This exceeds the maximum number of blocks per grid supported by CUDA (which happens to be $2^{31}-1$), so the work had to be divided up into multiple streams (more of this in the _Advanced features_ section).

## GPU optimisations
- _Memory Optimisations_: Because the program is highly compute-bound, there is not a lot of memory optimisations to be made. The character set `CHARSET_D` is stored in constant memory, which is faster to access than global memory and can be accessed across blocks. Furthermore, these accesses are coalesced as threads within the same warp access consecutive memory locations in `CHARSET_D`. This alignment allows memory accesses to be returned into a single transaction, reducing latency and the number of memory accesses needed. Shared memory is also used within the `add_times_block` and `add_times_final` reduction kernels to store partial sums computed by the threads in each block. This reduces the need to repeatedly access global memory, allowing for more efficient parallel reductions by minimising global memory traffic and leveraging the low-latency access of shared memory.
- _Parallel reduction_: The `add_times_block` and `add_times_final` kernels utilise parallel reduction in order to the times of the individual cracks in order to arrive at a total time. In `add_times_block`, each block of threads sums up its portion of the array of times and stores the result in shared memory. Then, within the same kernel, these partial sums are further reduced to a single value per block. The final reduction occurs in `add_times_final`, where the partial sums from all blocks are combined into a single total time. By using parallel reduction to compute the sum, the program can efficiently add the cracking time across all passwords in a highly parallel manner, which is particularly beneficial if there are a large number of passwords.
- _Kernel level configurations_: In the program, I found that using a block size of 256 (`THREADS_PER_BLOCK`) resulted in optimal performance. This block size is a multiple of the warp size of 32, and experimentally, it was not too small such that it resulted in idleness and not too large such that there was high resource contention. Based on the block size, the grid size is dynamically calculated depending on the total amount of work to be distributed (for `crack_one_password_gpu`, this is total number of password combinations to be processed). This grid size ensures that enough blocks are launched to cover all possible combinations. If the total number of blocks required is very large, the grid size is further divided among multiple streams to prevent overloading the GPU. These kernel-level configurations balance the workload across the GPU cores, ensuring that all resources are utilised effectively without creating unnecessary overhead or idle threads.
- _Thread coarsening_: Thread coarsening is applied in the `crack_one_password_gpu` kernel to reduce the overhead of launching too many threads and to improve memory access patterns. Instead of each thread handling a single password, each thread in this kernel processes multiple combinations, as defined by the `THREAD_COARSENING_FACTOR`, which is set to 4. This approach reduces the number of kernel launches and the number of blocks per grid needed, ultimately resulting in a more efficient use of the GPU's computational resources.

## Timing and speedups
As previously established, password cracking is extremely computationally expensive. Cracking a single password potentially requires iterating over all possible password combinations to find a match against the target hash (in `crack_one_password_seq`). This is explainably slow and is the primary bottleneck in the sequential version; however, it also proved to be the main hotspot for the GPU version. In the GPU version, the generation and checking of each possible password combination is parallelised, so an entire password space can be searched in much less time, effectively parallelising the hotspot and removing the bottleneck simultaneously (in `crack_one_password_gpu`). Because the length of the password is unknown to the cracker, the password space gets exponentially larger with each additional character added. We can see this exponential increase in computational time in both the timing plots for the non-uniform password lengths.

| Sequential and GPU times | GPU only times |
|---------|---------|
| ![times.png](https://github.com/pollyren/md5cracker/blob/main/results/times.png?raw=true) | ![times_gpu.png](https://github.com/pollyren/md5cracker/blob/main/results/times_gpu.png?raw=true) |
| ![times_unif.png](https://github.com/pollyren/md5cracker/blob/main/results/times_unif.png?raw=true) | ![times_unif_gpu.png](https://github.com/pollyren/md5cracker/blob/main/results/times_unif_gpu.png?raw=true) |

These plots were generated on the Peanut cluster with the following specifications:
```
Machine specifications: "NVIDIA GeForce GTX 1080"
  CUDA Driver Version / Runtime Version          12.5 / 12.1
  CUDA Capability Major/Minor version number:    6.1
  Total amount of global memory:                 7.92 GBytes (8499494912 bytes)
  GPU Clock rate:                                1734 MHz (1.73 GHz)
  Memory Clock rate:                             5005 Mhz
  Memory Bus Width:                              256-bit
```
The timing results can be replicated by running `sbatch generate_graphs.sh` from the `utils/` directory using the already-generated password lists in the `inputs/` directory. Ensure that the environment variables have been properly initialised using the `setup_env.sh` script.

We can also see from the bottom plots that once variable-length passwords are removed from the equation and cracking is just run on length-4 passwords, there is a linear increase in the computation time with an increasing number of passwords for both the sequential and GPU versions. This shows that the computational complexity of the algorithm scales fairly proportionally with the number of passwords. However, we do not see this same linear trend in the variable-length password timing, which is likely the result of limitations in speedups and synchronisation overhead. For one, the process of reading input files and writing the output is sequential in nature, but these operations are not the main performance bottlenecks compared to the computationally intensive, password cracking. Furthermore, the introduction of increasing block sizes and streams also raises the need for more synchronisation, which can also limit speedups. Applying thread coarsening also causes some of these computations to be sequentialised. Also, since much of the work is done in parallel, some threads may doing unnecessary work, i.e., exploring a part of the password space that would not have been explored in the sequential version, which also results in some additional overhead.

## Advanced features
- _Unified memory_: Unified memory is used throughout the code to manage memory allocations that are accessible by both the CPU and GPU, reducing the need to perform expensive memcpy's between host and device. In the program, unified memory is utilised with the `cudaMallocManaged` function. When reading in the hashes and plaintext passwords from generated by the scripts, these passwords are stored in unified memory so the device can read the hashes when attempting guesses in `crack_one_password_gpu` and compare against the actual plaintext password in `check_cracks_gpu` without the need to transfer a potentially long list of passwords and hashes. Additionally, unified memory is used within the `crack_passwords_gpu` function to store the cracked passwords. This choice was made in order to make the report generation process, i.e., printing the hash and the corresponding cracked password, more straightforward, without the need to memcpy. 
- _Streams and grid-level concurrency_: Streams are implemented not so much to perform asychronous memcpy's, but as a method to overcome the vastness of the password search space in `crack_passwords_gpu`. Using the default stream to launch threads is only sufficient for passwords up to 6 characters; for passwords longer than 6 characters, the number of blocks required to process all password combinations exceeds the maximum number of blocks that can be launched in a single kernel. As such, the workload is split across multiple CUDA streams. The number of streams needed is determined dynamically based on the number of blocks needed to explore all possible password combinations. All of these kernels are launched asynchronously so the entire password space can be explored simultaneously, and the results are afterwards synchronised.
- _Events_: Events are used to measure the time taken for to crack each password in a list, which is useful for performance analysis. In the `crack_passwords_gpu` function, `start` and `stop` events are created and used to record the start and stop times associated with the password cracking process for each password. Then, the elapsed time is calculated using `cudaEventElapsedTime`. This timing information is provided as an output to the user via the report generation process.

## Directory structure
```
md5cracker
├── inputs
│   ├── N_hashed.txt
│   ├── N_plain.txt
│   ├── Nu_hashed.txt
│   ├── Nu_plain.txt
├── README.md
├── results
│   ├── analyse_results.py
│   ├── times.csv
│   ├── times_gpu.png
│   ├── times.png
│   ├── times_unif.csv
│   ├── times_unif_gpu.png
│   └── times_unif.png
├── run.sh
├── setup_env.sh
├── src
│   ├── cracker.cu
│   ├── Makefile
│   ├── md5.cu
│   └── md5.cuh
└── utils
    ├── generate_graphs.sh
    ├── generate_passwords.py
    ├── run_gpu.sh
    └── run_seq.sh
```